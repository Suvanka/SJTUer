# 设计文档
## 项目架构
![](workflow.png)

## 环境依赖

|  名称   |  版本   |
| :-----: | :-----: |
| Python  |  3.10   |
| Django  |  4.0.2  |
|   Vue   |  3.3.4  |
| Node.js | 18.16.0 |
|   Npm   |  9.5.1  |


## git版本管理

### 代码管理
Git作为是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。Git支持版本库本地化，支持离线提交，相对独立不影响协同开发；同时支持快速切换分支方便合并，比较合并性能好。故而我们组使用Git管理代码。

### 分支管理
本项目的主分支为master分支，其余各分支以组员的名字命名。各位组员开发完一定的功能之后，先上传到自己的远程仓库分支进行备份；如果该功能已基本完成，或者其他成员的功能需要基于该功能进行开发，则将自己的分支merge到master分支。各位成员将从master分支拉取最新的代码。因此，master分支是用于汇总完善功能的分支，而自己的分支则主要起备份作用。

![](https://notes.sjtu.edu.cn/uploads/upload_d8654b1da5d41b3cfa74fe9ee55f8321.png)

## 前端组件设计

### 侧边栏

### 搜索框组件

搜索框提供各种常用搜索引擎和网站的搜索服务，包括*百度、谷歌、必应、搜狗、360、知乎、有道、CSDN、Github、bilibili*等10种。搜索栏由左侧引擎图标、中间的输入框和右侧的执行按钮组成。用户将鼠标悬浮在搜索引擎图标上，下方就会显示切换面板，可从上述10种应用中选择。用户在输入框输入搜索内容后，按右侧按钮或键盘上的回车键均可弹出搜索结果页面。

### 常用网站组件

常用网站组件默认提供交大常用网址索引，如教务处、教学信息服务网、canvas、邮箱等，也提供大众常用网站，如百度、知乎、b站等。在登录模式下，用户可以对网站进行增加、删除、修改操作，定制个性化常用网站。点击常用网站最后的加号按钮，可以新增网站；在已有网站上右键点击，会弹出修改删除的操作框，供用户进行修改收藏名称或删除该常用网站。

### 资讯组件

### todolist组件

### 诗歌组件

### 人流量组件

### 壁纸切换和AI文生图组件

壁纸组件提供三种切换壁纸的方式：预设炫彩壁纸、上传本地图片和AI创作壁纸。其中，预设壁纸提供了五种精心设计的、主题鲜明的渐变色壁纸，具有简洁明快、清新优雅的效果；上传本地图片部分提供文件接口，用户可自主选择图片上传并设为壁纸；AI创作壁纸部分，用户可随心所欲输入中英文提示词或句子，并选择是否需要高清图片，[后端](#ai文字生成图片组件)通过阿里云图像生产技术生成符合要求的图片并设为壁纸，免去了用户想要某一主题的壁纸但苦于在互联网海量图片中搜索的烦恼，并且可按照用户的心情随变随换，提供个性化、即时化、轻便化的服务。

### 天气组件

天气组件主要调用了和风天气的桌面端网站天气插件。该组件具有快速集成、样式丰富的优点，包括当前天气实况、三日天气预报、空气质量、气象灾害预警、降雨预报等，并且能够自动确定用户当前城市，支持切换全国任意城市，背景会随着当前天气状况和昼夜时间而变化。

### 前端信息获取（Axios）

由于本项目是前后端分离的项目，因此前端与后端通信必不可少。

前端通过Axios库的函数发起POST请求到后端的某个路径，后端Django进行路由之后，选择对应的函数进行处理，最后返回一个JSON格式的响应，前端接收响应之后执行`.then`子句中的内容。

值得一提的是，前端需要传递给后端的数据，通过POST请求进行传递，具体而言就是存储在params这个变量中。

```js
const siteName = this.addName;
this.siteFlag = false;
var that = this;
var params = new URLSearchParams();
var jaccount = sessionStorage.getItem("jaccount");

params.append("jaccount", jaccount);
params.append("refactor_site_name", siteName || ""); 
params.append("refactor_site_url", that.siteUrl); 

// 发送POST请求
axios
    .post("http://localhost:8000/index/refactor_site/", params)
    .then(function (response) {
    console.log(response.data["key"]);
    if (response.data["key"] == 1) {
        that.showMessage("网站修改成功！");
        location.reload();
    }
    if (response.data["key"] == 0) {
        that.showMessage("没有检测到您的输入！");
    }
})
    .catch(function (error) {
    // 报错处理
    console.log(error);
});
```

## 后端结构设计

### 爬虫获取数据

#### 资源获取

在本次项目中需要获取网络公开的资源数据：教务处通知公告、交大新闻、知乎热搜、微博热搜、B站热搜、食堂数据、图书馆数据等。首先需要通过开发者工具调取相关数据接口以发送请求，并针对html、json、xml不同格式进行内容提取。

#### 提升运行效率

考虑后端采用python语言编写可能导致运行速度较慢，同时顺序访问各资源会造成大量的时间浪费，故考虑设计python3.5版本后出现的异步功能实现多线程池工作。

### ORM数据库模型

#### 数据库设计

针对项目中的开发需求，设计数据库结构E-R图如下：

![](数据建模.png)

考虑本项目为小型工程项目，为提升运行效率采用轻便的SQLite作为后台数据库管理。

#### 数据库操作

为避免直接编写SQL语句导致可能的SQL注入问题（详见“安全需求设计”），采用django中的Model层进行ORM操作，针对前端发起的修改数据库内容的请求，编写相应的数据表内容查找、增加、修改、删除操作。

### Jaccount登录组件

根据数据库设计模块中的ER图可以确定，用户的唯一标识符是数据库需要保存的核心数据。在本项目中，采用OAuth2.0协议，调用Jaccount API进行第三方验证。

Jaccount登录的整体流程如下所示：

![图片1](pic/图片1.png)

- 进行Jaccount接口申请，获取`client_id` ，`client_secret`；
- 后端服务器构造POST请求，发送给Jaccount认证服务器，包含`client_id` ，`client_secret`，验证URL，重定向URL等信息；
- 页面跳转到Jaccount认证页面，用户输入账号密码；
- 认证服务器返回一个Token给后端服务器，服务器保存Token，并且重定向到主页面；
- 主页面加载函数中，借助Token向资源服务器（与认证服务器可以不是同一个）请求数据，资源服务器返回Jaccount账号、姓名等身份信息，身份信息存入后端数据库，同时再向前端传递。

以上部分关键代码如下：

```python
# oauth.py
# 定义OAuth变量，储存CLIENT_ID，CLIENT_SECRET和关键URL
oauth = OAuth()
oauth.register(
    name='jaccount',
    client_id = JACCOUNT_CLIENT_ID,
    client_secret = JACCOUNT_CLIENT_SECRET,
    access_token_url='https://jaccount.sjtu.edu.cn/oauth2/token',
    authorize_url='https://jaccount.sjtu.edu.cn/oauth2/authorize',
    api_base_url='https://api.sjtu.edu.cn/',
    client_kwargs={
        "scope": "basic",
        "token_endpoint_auth_method": "client_secret_basic",
        "token_placement": "header",
    },
)
jaccount = oauth.jaccount

# view.py
# 执行跳转到登录页面，返回token的逻辑，再跳转回主页面的逻辑
@csrf_exempt
def authorize(request):
    token: dict = jaccount.authorize_access_token(request)
    claims = jwt.decode(token.pop('id_token'),
                        jaccount.client_secret, claims_cls=CodeIDToken)
    claims.validate()
    request.session['token'] = token
    request.session['user'] = claims

    redir_uri = f"http://localhost:5173/" 
    return redirect(redir_uri)

# 通过token向资源服务器请求身份信息
def jac(request):
    token = request.session['token']
    access_token = token['access_token']
    requests.packages.urllib3.disable_warnings()
    result = requests.get(f'https://api.sjtu.edu.cn/v1/me/profile?access_token={access_token}', verify=False)
    return result.json()

```

采用Jaccount登录的其中一个好处在于，Jaccount采取了会话机制，一旦登录成功，资源服务器端会建立一个会话，同时返回一个cookie给后端服务器。只要Jaccount账户不登出，每次发送请求的时候都会附带这个cookie，资源服务器就能够返回原先已创建的会话。因此，本项目登录之后，不会因为刷新等操作丢失用户信息，具有较好的鲁棒性；另外，如果当前系统中登录过Canvas等网站，可以借助Session机制直接完成认证，不需要输入密码，具有便捷性。

值得注意的是，后端服务器获取用户信息之后，还需要通过axios的请求和响应，将用户信息返回给前端，前端才能够显示用户名。

### API调取与数据处理

为便于前端不同组件的调用，后端需针对 `GET` 请求和 `POST` 请求编写对应的后端API，同时考虑前端对于数据内容获取的需求，需要将资讯信息和数据库信息统一整理为JSON格式作为前端请求的响应。

### AI文字生成图片组件

AI文生图组件主要调用了阿里云视觉智能开放平台下的[图像生产](https://help.aliyun.com/document_detail/144977.html)技术，但为了提供更好的用户体验，后端还需进行一系列处理。

首先，后端从前端获取三个参数：文生图提示词 `prompt` 、 是否需要生成高清图的参数 `need_highres` 、 页面尺寸 `page_size` 。其中前两个参数由用户输入，第三个参数由前端直接获取。由于阿里云文生图功能仅提供几种预设尺寸，因此需要根据实际页面尺寸找出最接近的预设尺寸，最后再使用 `cv2.resize` 方法进行缩放。

接着，对提示词 `prompt` 进行处理。根据AI画图的提示词规则，在用户输入的提示词之后自动添加一系列提高绘图质量的关键词，例如 *wallpaper, masterpiece, 8k, best quality, highres, ultra detailed*，降低产生劣质图片的概率。

然后，调用阿里云图像生产API。但由于阿里云的处理流程较为繁琐，需要多步请求。首先将提示词和页面尺寸传给文生图函数 `img_gen` ，得到任务id；再根据id调用请求结果函数 `get_res` ，轮询任务状态直到获得图片url；再按照用户需求选择是否生成高清图片，如果需要就将刚才的url传给图像超分函数 `super_res` ，得到任务id，后续轮询操作同上。需要注意的是，由于阿里云的图像超分功能仍在测试中，所以耗时较长，约3~5分钟，而生成预设尺寸的原图仅需约10秒。

最后，从url下载图片到本地，进行缩放处理后返回路径。同时，将路径信息存入数据库，并给[前端](#壁纸切换和ai文生图组件)返回响应。

## 安全需求设计

### CSRF攻击防范

在django中采用 `django.middleware.csrf.CsrfViewMiddleware` 中间件防范可能出现的CSRF攻击，同时对业务中运行的必要请求视图添加 `@csrf_exempt` 注释以免除中间件的保护，这部分的防范在前端实现。

在前端，对于业务中的必要请求通过正则表达式拦截器防范CSRF攻击，具体代码如下：

```
axiosInstance.interceptors.request.use((config) => {
  config.headers['X-Requested-With'] = 'XMLHttpRequest'
  const regex = /.*csrftoken=([^;.]*).*$/
  config.headers['X-CSRFToken'] = document.cookie.match(regex) === null ? null : document.cookie.match(regex)[1]
  return config
})
```

### SQL注入防范

在django中不直接使用SQL语句进行数据库的访问，而是使用对象关系映射（Object Relational Mapping）来做数据的增删改查。ORM框架在运行时就能参照映射文件的信息，把对象持久化到数据库中，从而有效地避免了SQL注入攻击。

### 点击劫持防范

现代浏览器尊重 `X-Frame-Options HTTP` 头，它表明是否允许在框架或 `iframe` 中加载资源。如果响应包含值为 `SAMEORIGIN` 的头，那么只有当请求来自同一个网站时，浏览器才会在框架中加载资源。如果头被设置为 `DENY`，那么无论请求是由哪个网站发出的，浏览器都会阻止资源在框架中加载。

在django中，使用一组可用于覆盖中间件或仅为某些视图设置头的视图装饰器。这样，`X-Frame-Options HTTP` 头只有在响应中还没有出现的情况下，才会被中间件或视图装饰者设置。

django中采用 `django.middleware.clickjacking.XFrameOptionsMiddleware` 即可为网站的所有响应设置相同`X-FrameOptions` 值